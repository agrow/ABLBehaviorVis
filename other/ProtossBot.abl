package eisbot.abl.java;

import eisbot.proxy.*;
import eisbot.proxy.wmes.*;
import eisbot.proxy.wmes.unit.*;
import eisbot.proxy.wmes.unit.protoss.*;
import eisbot.proxy.filter.*;
import eisbot.abl.*;
import eisbot.abl.actions.*;
import eisbot.abl.sensors.*;
import eisbot.abl.wmes.*;
// import eisbot.abl.wmes.requests.*;
import java.awt.Point;

constants eisbot.abl.StarCraftConstants;
/**
 * 
 */ 
behaving_entity ProtossBot {

	// actions
	register act attackMovePixel(int, int, int) with AttackMovePixel;
	register act attackMoveTile(int, int, int) with AttackMoveTile;
	register act attackUnit(int, int) with AttackUnit;
	register act rightClickPixel(int, int, int) with RightClickPixel;
	register act rightClickTile(int, int, int) with RightClickTile;
	register act rightClickUnit(int, int) with RightClickUnit;
	register act train(int, int) with Train;
	register act buildTile(int, int, int, int) with BuildTile;
	register act buildAddon(int, int) with BuildAddon;
    register act research(int, int) with Research;
	register act upgrade(int, int) with Upgrade;
	register act stop(int) with Stop;
	register act holdPosition(int) with HoldPosition;
	register act patrolPixel(int, int, int) with PatrolPixel;  
	register act patrolTile(int, int, int) with PatrolTile;
	register act follow(int, int) with Follow;
	register act setRallyPositionPixel(int, int, int) with SetRallyPositionPixel;
	register act setRallyPositionTile(int, int, int) with SetRallyPositionTile;
	register act setRallyUnit(int, int) with SetRallyUnit;
	register act repair(int, int) with Repair;
	register act morph(int, int) with Morph;
	register act burrow(int) with Burrow;
	register act unburrow(int) with Unburrow;
	register act siege(int) with Siege;
	register act unsiege(int) with Unsiege;
	register act cloak(int) with Cloak;
	register act decloak(int) with Decloak;
	register act lift(int, int) with Lift;
	register act landTile(int, int, int) with LandTile;
	register act load(int, int) with Load;
	register act unload(int, int) with Unload;
	register act unloadAll(int) with UnloadAll;
	register act unloadAllPositionPixel(int, int, int) with UnloadAllPositionPixel;
	register act unloadAllPositionTile(int, int, int) with UnloadAllPositionTile;
	register act cancelConstruction(int) with CancelConstruction;
	register act haltConstruction(int) with HaltConstruction;
	register act cancelMorph(int) with CancelMorph;
	register act cancelTrain(int) with CancelTrain;
	register act cancelTrainSlot(int, int) with CancelTrainSlot;
	register act cancelAddon(int) with CancelAddon;
	register act cancelResearch(int) with CancelResearch;
	register act cancelUpgrade(int) with CancelUpgrade;
	register act useTech(int, int) with UseTech;
	register act useTechPositionPixel(int, int, int, int) with UseTechPositionPixel;
	register act useTechPositionTile(int, int, int, int) with UseTechPositionTile;
    register act useTechTarget(int, int, int) with UseTechTarget;
	 
	// unit sensors 
    register wme GeyserWME with GasSensor;
    register wme MineralWME with MineralSensor;
    register wme PlayerUnitWME with PlayerUnitSensor;
    register wme EnemyUnitWME with EnemyUnitSensor;
    register wme ParticleWME with ParticleFilterSensor;
    register wme NeutralUnitWME with NeutralUnitSensor;
    register wme NeutralEggWME with NeutralUnitSensor; 
  
	// Protoss units
    register wme AssimilatorWME with PlayerUnitSensor;
    register wme CannonWME with PlayerUnitSensor;
    register wme CyberneticsCoreWME with PlayerUnitSensor;
    register wme DragoonWME with PlayerUnitSensor;
    register wme ForgeWME with PlayerUnitSensor;
    register wme GatewayWME with PlayerUnitSensor;
    register wme NexusWME with PlayerUnitSensor;
    register wme ProbeWME with PlayerUnitSensor;
    register wme PylonWME with PlayerUnitSensor;
    register wme ZealotWME with PlayerUnitSensor;
    register wme CarrierWME with PlayerUnitSensor;
    register wme CitadelWME with PlayerUnitSensor;
    register wme GroundUnitWME with PlayerUnitSensor;
    register wme FleetBeaconWME with PlayerUnitSensor;
    register wme ObservatoryWME with PlayerUnitSensor;
    register wme ObserverWME with PlayerUnitSensor;
    register wme RoboticsFacilityWME with PlayerUnitSensor;
    register wme ScoutWME with PlayerUnitSensor;
    register wme StargateWME with PlayerUnitSensor;
    register wme FleeUnitWME with PlayerUnitSensor;
 
    // other sensors
    register wme PlayerWME with PlayerSensor;
    register wme BaseLocationWME with BaseLocationSensor;
    register wme StartingLocationWME with StartingLocationSensor;
    register wme RegionWME with RegionSensor;
    register wme TechTypenWME with TechTypeSensor;
    register wme UpgradeTypeWME with UpgradeTypeSensor;
    register wme UnitTypeWME with UnitTypeSensor;
    register wme MapWME with MapSensor;
    register wme NewUnitWME with NewUnitSensor;
    register wme ReconWME with ReconSensor;

	int earliestObsTiming = 7200;	// 5 minutes
	int beginAttackSize = 5;
	int endAttackSize = 0;
	int deathsAllowed = 3;
	int expoTiming = 66;
    int maxProbes = 70; 
 	int minZealots = 1;
    boolean techCarriers = false;
	int carrierTiming = 100;
      
/******************************************************************************
 * Start up
 *****************************************************************************/

	/**
	 * Wait for some of the sensors to Fire.
	 */
	sequential behavior startup() {

		with (success_test {
	    	(PlayerWME)	
	    	(PlayerUnitWME)	 
	    	(MineralWME)	
	    	(GeyserWME)	
		}) wait;
   
   		mental_act {
   			Logger.print("ABL", "Starting managers");
   			UnitQueryWME oracle = new UnitQueryWME();
   			BehavingEntity.getBehavingEntity().addWME(oracle);
   			TimerWME timer = new TimerWME();
   			BehavingEntity.getBehavingEntity().addWME(timer);
   		}
   		   
   		// Add some variance to the bot strategy 
   		mental_act {   			 
//   		  expoTiming = (int)(60.0 + Math.random()*20.0);   // 66 default, 60-80
            beginAttackSize = (int)(3.0 + Math.random()*8.0); // 5 default   		
//            techCarriers = (Math.random() < 1.6); 
//   		  carrierTiming = (int)(120.0 + Math.random()*40.0);   
//   		  minZealots = (int)(1.0 + Math.random()*2.0);   // 2
   			  
   			Logger.print("ABL", "Initial build parameters");
   			Logger.print("ABL", "\tZealots: " + minZealots);
   			Logger.print("ABL", "\tExpo Timing: " + expoTiming/2);
   			Logger.print("ABL", "\tInitial Army Size: " + beginAttackSize); 
   			Logger.print("ABL", "\tTeching carreirs: " + techCarriers);
   			Logger.print("ABL", "\tCarrier Timing: " + carrierTiming/2);
   		}
			
		subgoal startupAgent();
		
		with (persistent) subgoal WaitFrames(120);
	}  

	parallel behavior startupAgent() {
		spawngoal startConstructionManager();
		spawngoal startWorkerManager();
		spawngoal startStrategyManager();
		spawngoal startOperationsManager();
		spawngoal startProductionManager();
		spawngoal startScoutingManager();
		spawngoal keyPressListener();
	}
	
/******************************************************************************
 * Scouting Manager
 *****************************************************************************/

    parallel behavior startScoutingManager() {
	  	with (persistent) subgoal pickScout();
	  	with (persistent) subgoal scoutFlee();
    }
    
    sequential behavior pickScout() {
	    ProbeWME worker;
	    int workerID;

		subgoal WaitFrames(1000);	// dont scout for another 2 minutes 
	    
		with (success_test {
			(GatewayWME)
			!(ParticleWME typeID!=Zerg_Overlord typeID!=Zerg_Drone typeID!=Protoss_Probe typeID!=Terran_SCV)
        	worker = (ProbeWME active==true task==WORKER_MINE ID::workerID)
        	(Logger.print("ABL", "Picked worker"))
		}) wait;	
	
		// claim for scouting
		mental_act {
//	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Probe));
			worker.setTask(WORKER_SCOUT);
			worker.setPreviousHealth();
		}  
		 
		with (persistent when_succeeds) subgoal workerScout(worker, workerID);						 
//		subgoal WaitFrames(3000);	// dont scout for another 2 minutes 
	}    
	
	/**
	 * Scout known enemy locations.
	 */	
    sequential behavior workerScout(ProbeWME worker, int workerID) {
    	precondition {
        	particle = (ParticleWME typeID!=Zerg_Overlord typeID!=Zerg_Drone typeID!=Protoss_Probe typeID!=Terran_SCV)
        	(Logger.print("ABL", "Particle scouting"))
    	}
		specificity 2;
    	  
		context_condition {	
			(ProbeWME ID==workerID)	// force a sensor update
        	(worker.getHitPoints() > 0)    
		}
		
		int x, y;		
		boolean foundParticle = true;
		
		mental_act {
        	particle = ABLStarCraftBot.getGame().getParticleFilter().getRandomBuildingParticle();
        	
        	if (particle != null) {
				x = particle.getX() - 10 + (int)(Math.random()*20); 
				y = particle.getY() - 10 + (int)(Math.random()*20); 
			}
			else { 
				foundParticle = false;
				x = worker.getX();
				y = worker.getY();
			}		
		}      
 
		// is there anything to scout?
		subgoal continueBehavior(foundParticle);
		
		act rightClickTile(workerID, x, y);
		subgoal WaitFrames(48);
		
		with (success_test { 
        	(ProbeWME ID==workerID order==PlayerGuard)
		}) wait;	
	}	 
	

	/**
	 * Scout for bases.
	 */	
    sequential behavior workerScout(ProbeWME worker, int workerID) {
    	precondition { 
        	map = (MapWME)
        	timer = (TimerWME)
    	}
		specificity 1;
    	
		context_condition {	
			(ProbeWME ID==workerID)	// force a sensor update
        	(worker.getHitPoints() > 0)    
		}
	
		int x, y;		
		Point point;
		
		mental_act {
			if (timer.getFrameCount() > 12000) {	// scout everywhere after 12 minutes
				point = map.getNextScoutLocation();			
			}		
			else {
				point = map.getNextStartLocation();
			}

			x = point.x; 
			y = point.y;
        	Logger.print("ABL", "scouting " + x + " " + y);
		}    
		 
		act rightClickTile(workerID, x, y);
		subgoal WaitFrames(2);

		with (success_test {
        	(ProbeWME ID==workerID order==PlayerGuard)
		}) wait;	 
    }
 
    sequential behavior scoutFlee() {
//		specificity 3; 
		
	    ProbeWME worker;
	    int x, y, workerID, target, orderTarget, targetX, targetY;
	    
		with (success_test {
        	worker = (ProbeWME task==WORKER_SCOUT takenDamage==true ID::workerID targetX::targetX targetY::targetY)        	
//        	worker = (ProbeWME task==WORKER_SCOUT ID::workerID targetX::targetX targetY::targetY)        	
//			(EnemyUnitWME target::target orderTarget::orderTarget)
//			(target==workerID || orderTarget==workerID) 
        	(NexusWME x::x y::y)
        	(Logger.print("ABL", "Scout fleeing"))
		}) wait;	
		 
		act rightClickTile(workerID, x, y);
		subgoal WaitFrames(240);		 

		mental_act {
			worker.setPreviousHealth();
		}		
		 
		act rightClickTile(workerID, targetX, targetY);
		subgoal WaitFrames(2);		
	}
 	 

/******************************************************************************
 *Strategy Manager
 *****************************************************************************/
 
    parallel behavior startStrategyManager() {
	  	with (persistent) subgoal strategyManager();
    }
    
	// expo
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed>=expoTiming minerals>=350)
        	!(NexusWME active==false)
        	!(ExpoHoldWME)
        	!(ConstructionWME type==Protoss_Nexus)
        	(MapWME isExpoAvailable==true)        	
        }
        specificity 4; 
        
    	mental_act { 
   			Logger.print("StrategyManager", "Requesting to build a Nexus");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Nexus));
   		}

		spawngoal delayNextExpo(8000, false); 
        subgoal WaitFrames(24); 
	} 
	
    sequential behavior delayNextExpo(int delay, boolean produceNexus) {
    	mental_act { 
	        BehavingEntity.getBehavingEntity().addWME(new ExpoHoldWME());
   		}
 	
        subgoal WaitFrames(delay);
        
    	mental_act { 
	        BehavingEntity.getBehavingEntity().deleteAllWMEClass("ExpoHoldWME");
	        
	        if (produceNexus) {
				BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Nexus));
	        }
   		} 
    }	

   	// obs 
    sequential behavior strategyManager() {
        precondition {
        	(ReconWME numObs<3) 
        	(PlayerWME supplyUsed::used supplyTotal::total)
        	(used<=(total - 2))
        	(ObservatoryWME active==true)        	
        	!(TrainUnitWME type==Protoss_Observer) 
			(RoboticsFacilityWME buildTimer==0 powered==true) 
        }
        specificity 5;
 
   		mental_act {
  			Logger.print("StrategyManager", "Requesting to build a Observer");
	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Observer));
   		}

        subgoal WaitFrames(24);
    }       
    
	// observatory    
    sequential behavior strategyManager() {
        precondition { 
        	!(ObservatoryWME)
        	(RoboticsFacilityWME active==true powered==true)
        	!(ConstructionWME type==Protoss_Observatory)
        }
        specificity 5;
        
    	mental_act { 
   			Logger.print("StrategyManager", "Requesting to build a Observatory");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Observatory));
   		}

        subgoal WaitFrames(24);
	}
    
	// robobay at 30+  
    sequential behavior strategyManager() {
        precondition {
        	(ReconWME enemyCloakingTech==true)
   			(TimerWME frameCount>=earliestObsTiming)
        	!(ConstructionWME type==Protoss_Robotics_Facility)
        	!(RoboticsFacilityWME)
   			(Logger.print("ABL", "Starting OBS tech")) 
        }
        specificity 5;
        
    	mental_act { 
   			Logger.print("StrategyManager", "Requesting to build a Robotics facility");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Robotics_Facility));
   		}

		spawngoal delayNextExpo(3000, true); 	// delay expo until obs tech is up
        subgoal WaitFrames(24);
	}

	// standard obs timing (2nd gas) 
    sequential behavior strategyManager() {
        precondition {
        	!(RoboticsFacilityWME)
        	(ReconWME numAssimilators>=2)
        	!(ConstructionWME type==Protoss_Robotics_Facility)
   			(Logger.print("ABL", "Starting OBS tech")) 
        }
        specificity 3;
        
    	mental_act { 
   			Logger.print("StrategyManager", "Requesting to build a Robotics facility");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Robotics_Facility));
   		}

        subgoal WaitFrames(2);
	}
	
	sequential behavior strategyManager() {
        precondition {
        	(techCarriers==true)
        	(PlayerWME supplyUsed>=carrierTiming)
        	!(StargateWME)
        	(ReconWME numAssimilators>=2)
        	!(ConstructionWME type==Protoss_Stargate)
        }
        specificity 3; 
        
    	mental_act { 
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Stargate));
   		}

        subgoal WaitFrames(2);
	}

	sequential behavior strategyManager() {
        precondition {
        	(StargateWME)
        	!(FleetBeaconWME)
        	!(ConstructionWME type==Protoss_Fleet_Beacon)
        }
        specificity 3; 
        
    	mental_act { 
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Fleet_Beacon));
   		}

        subgoal WaitFrames(2);
	} 
	 
    sequential behavior strategyManager() {
        precondition {
        	(FleetBeaconWME ID::unitID buildTimer==0 upgradeTimer==0)
        	player = (PlayerWME minerals>=100 gas>=100 upgradedCarrierCapacity==false upgradingCarrierCapacity==false)
        }
        specificity 6; 

		mental_act {
			Logger.print("StrategyManager", "Upgrading carrier capacity");
		}

		act upgrade(unitID, Carrier_Capacity);
        subgoal WaitFrames(24);
    } 
	 
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed::used supplyTotal::total)
        	(used<=(total - 12)) 
        	!(TrainUnitWME type==Protoss_Carrier) 
			(FleetBeaconWME buildTimer==0 powered==true) 
        }
        specificity 2;
  
   		mental_act {
  			Logger.print("StrategyManager", "Requesting to build a carrier");
	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Carrier));
   		}
 
        subgoal WaitFrames(24);
    }      	 

	// Pylon on 8
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed==16)
        	!(ConstructionWME type==Protoss_Pylon)
        	!(PylonWME)
        }
        specificity 3;
 
    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a pylon");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Pylon));
   		}
   		
        subgoal WaitFrames(24);
   	}      
      
	// Build a gateway at 10 supply
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed==20)
        	!(ConstructionWME type==Protoss_Gateway)
        	!(GatewayWME)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a gateway");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Gateway));
   		}
   		
        subgoal WaitFrames(24);
   	}

	// Build an assimilator at 11 supply
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed==22)
        	!(ConstructionWME type==Protoss_Assimilator)
        	!(AssimilatorWME)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build an assimilator");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Assimilator));
   		}
   		
        subgoal WaitFrames(24);
   	}

	// forge  	
    sequential behavior strategyManager() {
        precondition {
        	(ReconWME numZealots::zealots numDragoons::dragoons)
        	((zealots + dragoons) >= 12)
        	!(ConstructionWME type==Protoss_Forge)
        	!(ForgeWME)
        } 
        specificity 3;
 
    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a forge");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Forge));
   		}
   		
        subgoal WaitFrames(24);
   	}

	// weapons 1
    sequential behavior strategyManager() {
        precondition {
        	(ForgeWME ID::unitID buildTimer==0 upgradeTimer==0 powered==true) 
        	player = (PlayerWME minerals>=100 gas>=100 weaponLevel==0 upgradingWeapons==false)
        }
        specificity 4;

		mental_act {  
			Logger.print("StrategyManager", "Upgrading Protoss Ground Weapons");
		}

		act upgrade(unitID, Protoss_Ground_Weapons);
        subgoal WaitFrames(24);
    }
 
	// armor 1
    sequential behavior strategyManager() {
        precondition {
        	(ForgeWME ID::unitID buildTimer==0 upgradeTimer==0 powered==true) 
        	player = (PlayerWME minerals>=100 gas>=100 armorLevel==0 upgradingArmor==false)
        }
        specificity 3;

		mental_act { 
			Logger.print("StrategyManager", "Upgrading Protoss Armor");
		}

		act upgrade(unitID, Protoss_Armor);
        subgoal WaitFrames(24);
    }

	// citadel   	
    sequential behavior strategyManager() {
        precondition {
        	(ReconWME numZealots>=6)
        	!(ConstructionWME type==Protoss_Citadel_of_Adun)
        	!(CitadelWME)
        }
        specificity 3; 

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a citadel");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Citadel_of_Adun));
   		}
   		  
        subgoal WaitFrames(24);
   	}

	// zealot legs
    sequential behavior strategyManager() {
        precondition {
        	(CitadelWME ID::unitID buildTimer==0 upgradeTimer==0 powered==true)
        	player = (PlayerWME minerals>=150 gas>=150 upgradedZealotLegs==false upgradingZealotLegs==false)
        }
        specificity 4;

		mental_act { 
			Logger.print("StrategyManager", "Upgrading zealot legs");
		}

		act upgrade(unitID, Leg_Enhancements);
        subgoal WaitFrames(120);
    }
 
	// Additional assimilators
    sequential behavior strategyManager() {
        precondition { 
        	(AssimilatorWME)
        	(NexusWME numWorkers>=10 x::nx y::ny)
        	(GeyserWME x::gx y::gy) 
        	(Math.abs(nx - gx) < 10 && Math.abs(ny - gy) < 10)
        	!(ConstructionWME type==Protoss_Assimilator)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build an additional assimilator");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Assimilator));
   		}
   		
        subgoal WaitFrames(24);
   	}

   	// produce a zealot as soon as possible 
    sequential behavior strategyManager() {
		precondition {
        	!(ZealotWME)
        	!(TrainUnitWME type==Protoss_Zealot)
			(GatewayWME active==true)
		}
        specificity 3;
        
    	mental_act {
  			Logger.print("StrategyManager", "Requesting to build a Zealot");
  			
  			for (int i=0; i<minZealots; i++) {  			
		        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Zealot));
		    }
		    
//	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Zealot));
   		}
   		
        subgoal WaitFrames(12);
   }

   	// pump zealot if lots of money
    sequential behavior strategyManager() { 
        precondition {
        	(PlayerWME supplyUsed::used supplyTotal::total minerals>600)
        	(used<=(total - 4))
        	building = (PlayerUnitWME typeID==Protoss_Gateway ID::unitID trainTimer==0 buildTimer==0 powered==true)
        }
        specificity 2;

		act train(unitID, Protoss_Zealot);
        subgoal WaitFrames(24);
    }      	

	// Build a core at 13 supply
    sequential behavior strategyManager() {
        precondition {
        	(ZealotWME)
        	(PlayerWME supplyUsed>=26)
        	!(ConstructionWME type==Protoss_Cybernetics_Core)
        	!(CyberneticsCoreWME)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a core");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Cybernetics_Core));
   		}
   		
        subgoal WaitFrames(24);
   	}

	// Build a second gateway at 16 supply
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed>=32)
        	!(ConstructionWME type==Protoss_Gateway)
        	(GatewayWME ID::unitID)
        	!(GatewayWME ID!=unitID)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a gateway");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Gateway));
   		}
   		
        subgoal WaitFrames(24);
   	}
   		   	
   	// 2nd Pylon on 14
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed>=28)
        	!(ConstructionWME type==Protoss_Pylon)
        	(PylonWME ID::unitID)
        	!(PylonWME ID!=unitID)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a pylon");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Pylon));
   		}
   		
        subgoal WaitFrames(24);
   	}     

	// upgrade dragoon range
    sequential behavior strategyManager() {
        precondition {
        	player = (PlayerWME supplyUsed>34 minerals>=150 gas>=150 upgradedDragoonRange==false upgradingDragoonRange==false)
        	(CyberneticsCoreWME ID::unitID buildTimer==0 upgradeTimer==0 powered==true)
        }
        specificity 6;

		mental_act { 
			Logger.print("StrategyManager", "Upgrading dragoon range");
		}

		act upgrade(unitID, Singularity_Charge);
        subgoal WaitFrames(24);
    }

   	// pump goons 
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed::used supplyTotal::total)
        	(used<=(total - 4))
        	!(TrainUnitWME type==Protoss_Dragoon)
			(CyberneticsCoreWME buildTimer==0 powered==true)  // wait for core
        }
        specificity 2;
 
   		mental_act {
  			Logger.print("StrategyManager", "Requesting to build a dragon");
	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Dragoon));
   		}

        subgoal WaitFrames(24);
    }      	 
   	 
   	// pump probes at each nexus
    sequential behavior strategyManager() {
        precondition {
			(ReconWME numProbes<maxProbes numProbes::numProbes)
        	!(ConstructionWME)				// probe let probes interrupt buildings
        	!(TrainUnitWME type==Protoss_Probe)
			(NexusWME numWorkers<14 ID::nexusID x::nx y::ny)
			(MineralWME x::mx y::my)
			(Math.abs(nx - mx) < 10 && Math.abs(ny - my) < 10) 
        }
        specificity 2;
  
   		mental_act {
  			Logger.print("StrategyManager", "Requesting to build a probe at " + nexusID);
	        BehavingEntity.getBehavingEntity().addWME(new TrainUnitWME(Protoss_Probe, nexusID));
   		}

        subgoal WaitFrames(24);
    }    
    
   	// additional pylons
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed>34 supplyUsed::used supplyTotal::total)
        	((used*(1.0 + (double)used/800.0) + 2) >= total)
        	!(ConstructionWME type==Protoss_Pylon)
        	!(PylonWME buildTimer!=0)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a pylon");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Pylon));
   		} 
   		
        subgoal WaitFrames(24);
   	}     
   	
    // additional gateways
    sequential behavior strategyManager() {
        precondition {
        	(PlayerWME supplyUsed>expoTiming minerals>=400)
        	!(ConstructionWME)
        	!(GatewayWME buildTimer!=0)
        }
        specificity 3;

    	mental_act {
   			Logger.print("StrategyManager", "Requesting to build a gateway");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Gateway));
   		}

        subgoal WaitFrames(24);
   	}
      
   	// no action to perform
	sequential behavior strategyManager() {
        specificity 1;        
        subgoal WaitFrames(24);
   	}
   	
/******************************************************************************
 * Production Manager
 *****************************************************************************/

    parallel behavior startProductionManager() {
	  	with (persistent) subgoal productionManager();
    }

    // is there an obs request
    sequential behavior productionManager() {
        precondition {
        	trainUnitWME = (TrainUnitWME mineralCost::mins gasCost::gas type==Protoss_Observer type::type whatBuilds::buildType)
        	(PlayerWME minerals>=mins gas>=gas)
        	building = (PlayerUnitWME typeID==buildType ID::unitID trainTimer==0 buildTimer==0 powered==true)
        	!(ConstructionWME resourcesClaimed==false)
        }
        specificity 3;

		act train(unitID, type);
		subgoal WaitFrames(120);

		mental_act {
			BehavingEntity.getBehavingEntity().deleteWME(trainUnitWME);
		}
    }  
    
    // is there a unit request
    sequential behavior productionManager() {
        precondition {
        	trainUnitWME = (TrainUnitWME mineralCost::mins gasCost::gas type::type whatBuilds::buildType builder::buildingID)
        	(PlayerWME minerals>=mins gas>=gas)
        	building = (PlayerUnitWME typeID==buildType ID::unitID trainTimer==0 buildTimer==0 powered==true)
        	(buildingID==-1 || buildingID==unitID)
        	!(ConstructionWME resourcesClaimed==false)
        }
        specificity 2;

		act train(unitID, type);
		subgoal WaitFrames(24);

		mental_act {
			BehavingEntity.getBehavingEntity().deleteWME(trainUnitWME);
		}
    } 

    // is there a unit request (ignore construction if you have money)
    sequential behavior productionManager() {
        precondition {
        	trainUnitWME = (TrainUnitWME mineralCost::mins gasCost::gas type::type whatBuilds::buildType builder::buildingID)
        	(PlayerWME minerals>600)
        	building = (PlayerUnitWME typeID==buildType ID::unitID trainTimer==0 buildTimer==0 powered==true) 
        	(buildingID==-1 || buildingID==unitID)
        }
        specificity 2;

		act train(unitID, type);
		subgoal WaitFrames(24);

		mental_act {
			BehavingEntity.getBehavingEntity().deleteWME(trainUnitWME);
		}
    } 

    // nothing to produce
    sequential behavior productionManager() {
        specificity 1;
        subgoal WaitFrames(24);
    }
    
/******************************************************************************
 * Worker Manager
 *****************************************************************************/

    parallel behavior startWorkerManager() {
		with (persistent) subgoal mineMinerals();
		with (persistent) subgoal gasTransfer();  
		with (persistent) subgoal checkMinedOut();
		with (persistent) subgoal probeTransfer();
		with (persistent) subgoal manageWorkerHarass();
		with (persistent) subgoal manageBaseHarass();
		with (persistent) subgoal pullOffGas();
		with (persistent) subgoal pullOffGasDefense();
		with (persistent) subgoal putOnGas();
    }        

	/**
	 * Too much gas.
	 */
    sequential behavior pullOffGas() {
	    AssimilatorWME assimilator;
	    int gas, supplyUsed;
	    
		with (success_test {
			(PlayerWME gas::gas supplyUsed::supplyUsed)
			(ReconWME numAssimilators<=1)
			(gas >= 300 || supplyUsed<=20)	
        	assimilator = (AssimilatorWME targetWorkers>=3)				
			(Logger.print("ABL", "Pulling worker off gas"))
		}) wait;
		
		mental_act {
			assimilator.setTargetWorkers(1);		
		}

   		subgoal WaitFrames(2);		
    }
 
    sequential behavior pullOffGasDefense() {
	    AssimilatorWME assimilator;
	    int x, y, ex, ey;
	    
		with (success_test {
        	assimilator = (AssimilatorWME targetWorkers>0 x::x y::y)				
        	(ReconWME myNexusCount<=1)
        	(EnemyUnitWME x::ex y::ey isWorker==false isFlyer==false)
        	(Math.abs(ex - x) <= 8 && Math.abs(ey - y) <= 8) 
			(Logger.print("ABL", "Pulling worker off gas for DEFENSE"))
		}) wait;
		
		mental_act {
			assimilator.setTargetWorkers(0);		
	        BehavingEntity.getBehavingEntity().addWME(new GasHoldWME());	        
		}

		// prevent gas collection 
   		subgoal WaitFrames(500);		
		mental_act {
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("GasHoldWME");
		}
    }

	/** 
	 * Not enough gas.
	 */
    sequential behavior putOnGas() {
	    AssimilatorWME assimilator;
	    
		with (success_test {
			(PlayerWME gas <= 200 supplyUsed >= 20)	
			!(GasHoldWME)
        	assimilator = (AssimilatorWME targetWorkers<3)				
			(Logger.print("ABL", "Putting worker on gas"))
		}) wait;
		
		mental_act {
			assimilator.setTargetWorkers(3);		
		}

   		subgoal WaitFrames(2);		
    }
     
  	/**
  	 * Deal with worker harassment. 
  	 */
    sequential behavior manageWorkerHarass() {
    	int x, y, workerID, task, enemyX, enemyY, priorTarget;
    	ProbeWME worker;
    	int friends = 0;
    	boolean enemyWorker;
    	
		with (success_test {
			worker = (ProbeWME ID::workerID orderTarget::priorTarget task::task x::x y::y)
			(task==WORKER_MINE) 
			(EnemyUnitWME orderTarget==workerID x::enemyX y::enemyY isWorker::enemyWorker isFlyer==false) 
			(ReconWME MyNexusCount<=1)
			(Logger.print("ABL", "Dealing with harass"))
		}) wait;
		
		mental_act {
			worker.setTask(WORKER_DEFEND);					
			
			// has taken damage already
			if (worker.getShields() <= 10) {
			   friends = 1;
			}
			
			// being attacked by a military unit
			if (!enemyWorker) {
				friends = 5;
			}
		}
	
		spawngoal workerDefend(worker, workerID, enemyX, enemyY, priorTarget);		
   		subgoal WaitFrames(2);		
   		spawngoal getFriendHelp(x, y, enemyX, enemyY, friends);
   		subgoal WaitFrames(48);		
	}     

    sequential behavior manageBaseHarass() {
    	int x, y, buildingID, enemyX, enemyY;
    	int friends = 1;
    	 
		with (success_test {
			worker = (NexusWME x::x y::y ID::buildingID)
			(EnemyUnitWME orderTarget==buildingID x::enemyX y::enemyY) 
			(ReconWME MyNexusCount<=1)
			(Logger.print("ABL", "Dealing with base harass"))
		}) wait;
  
   		spawngoal getFriendHelp(x, y, enemyX, enemyY, friends);
   		subgoal WaitFrames(120);		
	}     

  
	/**
	 * Get assistance from another worker.
	 */
    sequential behavior getFriendHelp(int allyX, int allyY, int enemyX, int enemyY, int friends) {
    	precondition {   
    		(Logger.print("ABL", "Looking for friends: " + friends))
    		(friends > 0)
			worker = (ProbeWME ID::workerID orderTarget::priorTarget task::task x::x y::y)
			(task==WORKER_MINE)
        	(Math.abs(allyX - x) <= 7 && Math.abs(allyY - y) <= 7) 
    		(Logger.print("ABL", "Getting help from a friend: " + workerID))
    	}
    	specificity 2;
 
    	mental_act {
			worker.setTask(WORKER_DEFEND);					
    		friends = friends - 1;
		}    	
		
		spawngoal workerDefend(worker, workerID, enemyX, enemyY, priorTarget);		
   		subgoal WaitFrames(2);		 
   		spawngoal getFriendHelp(allyX, allyY, enemyX, enemyY, friends);
    }

	/**
	 * Enough workers are already supporting
	 */ 
    sequential behavior getFriendHelp(ProbeWME worker, int workerID, int enemyX, int enemyY, int friends) {
    	specificity 1;
    	succeed_step;
    }
    
	 /** 
	  * Handle harassment. 
	  */  
    sequential behavior workerDefend(ProbeWME worker, int workerID, int enemyX, int enemyY, int priorTarget) {

   		act attackMoveTile(workerID, enemyX, enemyY);  
   		subgoal WaitFrames(200);		
		subgoal returnToWork(worker, workerID, priorTarget);   		
   		subgoal WaitFrames(2);   				
    } 

	/**
	 * Return to gas.
	 */
    sequential behavior returnToWork(ProbeWME worker, int workerID, int priorTarget) {
    	precondition {
    		assimilator = (AssimilatorWME ID::assimilatorID)
			(assimilator.getIsAssigned(workerID))
			(Logger.print("ABL", "Returning to gas"))
    	}
    	specificity 2;
     	    	
		act rightClickUnit(workerID, assimilatorID);   		
   		subgoal WaitFrames(2);   				
		
		mental_act {
			worker.setTask(WORKER_GAS);		
		}
    }

	/**
	 * Return to minerals.
	 */
    sequential behavior returnToWork(ProbeWME worker, int workerID, int priorTarget) {
    	precondition {
			(Logger.print("ABL", "Returning to minerals"))
    	}    	
    	specificity 1;    	    
      		
		act rightClickUnit(workerID, priorTarget);   		
   		subgoal WaitFrames(2);   				
		
		mental_act {
			worker.setTask(WORKER_MINE);		
		}
    }
 
    /**
     * Transfer probes to a new nexus when it is nearing completion.
     */    
    sequential behavior probeTransfer() {
    	int nexusID, nexusX, nexusY;
    	NexusWME nexus;
    
		with (success_test {
        	nexus = (NexusWME active==false buildTimer<200 buildTimer>150 ID::nexusID x::nexusX y::nexusY)
        	(Logger.print("ABL", "Trasferring workers"))
		}) wait;
		
		with (ignore_failure) subgoal transferWorkers(nexus, nexusID, nexusX, nexusY, 5);
		subgoal WaitFrames(100);
	} 
 
    /**
     * Transfers probes to the specified nexus. 
     */
    sequential behavior transferWorkers(NexusWME nexus, int nexusID, int nexusX, int nexusY, int count) {
    	precondition {
    	    (count > 0)
    		worker = (ProbeWME task==WORKER_MINE ID::unitID) 
    		(worker.getNexus() != null && worker.getNexus().getID() != nexusID)
        	minerals = (MineralWME ID::mineralID x::minX y::minY  timeSinceLastUse >= 1000)  
        	(Math.abs(nexusX - minX) <= 10 && Math.abs(nexusY - minY) <= 10)
    	}

        mental_act {
        	minerals.setAsUsed();
			if (worker.getNexus() != null) {		
				worker.getNexus().freeWorker(unitID);
			}
			
        	nexus.addWorker(unitID);
        	worker.setNexus(nexus);        	
   			count--;
        }

   		act rightClickUnit(unitID, mineralID);   		
		with (ignore_failure) subgoal transferWorkers(nexus, nexusID, nexusX, nexusY, count);
    }
 
    /**
     * Tell idle workers to mine nearby patches.
     */ 
    sequential behavior mineMinerals() {
    	int unitID, workerX, workerY;
    	ProbeWME worker;
    
		with (success_test {
        	worker = (ProbeWME task==WORKER_IDLE ID::unitID x::workerX y::workerY active==true)
		}) wait;
   		
   		subgoal selectMinerals(worker, unitID, workerX, workerY);
   		
   		mental_act {
   			worker.setTask(WORKER_MINE);
   		}
    }

    /**
     * Find nearby patches not recently selected.
     */
	sequential behavior selectMinerals(ProbeWME worker, int unitID, int workerX, int workerY) {
		precondition {
		    nexus = (NexusWME active==true x::x y::y)
        	(Math.abs(workerX - x) <= 10 && Math.abs(workerY - y) <= 10)
        	minerals = (MineralWME ID::mineralID x::minX y::minY  timeSinceLastUse >= 1000) 
        	(Math.abs(x - minX) <= 10 && Math.abs(y - minY) <= 10)
        }	
        specificity 2;

        mental_act {
        	minerals.setAsUsed();
        	nexus.addWorker(unitID);
        	worker.setNexus(nexus);        	
        }

   		act rightClickUnit(unitID, mineralID);   		
	}

	/**
	 * No nearby minerals, just go to a patch near one of the player's Nexusii 
	 */
	sequential behavior selectMinerals(ProbeWME worker, int unitID, int workerX, int workerY) {
		precondition {
		    nexus = (NexusWME x::x y::y)
        	minerals = (MineralWME ID:: mineralID x::minX y::minY)
        	(Math.abs(x - minX) <= 10 && Math.abs(y - minY) <= 10)
        }
        specificity 1;
        
        mental_act {
        	minerals.setAsUsed();
        	nexus.addWorker(unitID);
        	worker.setNexus(nexus);        	
        }
        
   		act rightClickUnit(unitID, mineralID);
	}

	/**
	 * Continuously check for new assimilators.
	 */
    sequential behavior gasTransfer() {
    	AssimilatorWME assimilator;
    	int ID, x, y, numWorkers, targetWorkers;
    	
		with (success_test {	 
        	assimilator = (AssimilatorWME active==true numWorkers::numWorkers targetWorkers::targetWorkers x::x y::y ID::ID)
        	(numWorkers!=targetWorkers)
		}) wait;
		
		with (ignore_failure) subgoal modifyGasCollectors(assimilator, ID, numWorkers, targetWorkers, x, y);		
		subgoal WaitFrames(48);
    }

	/**
	 * Add gas collectors (assume direct control)
	 */
	sequential behavior modifyGasCollectors(AssimilatorWME assimilator, int assimilatorID, int numWorkers, int targetWorkers, int x, int y) {
		precondition {
			(numWorkers < targetWorkers)
			worker = (ProbeWME task==WORKER_MINE ID::unitID x::workerX y::workerY active==true)
			(!assimilator.getIsAssigned(unitID))
        	(Math.abs(x - workerX) <= 10 && Math.abs(y - workerY) <= 10)
		}
		specificity 2;
	
   		mental_act {    	
			if (worker.getNexus() != null) {		   			
   				worker.getNexus().freeWorker(unitID);
   			}
   			
   			worker.setTask(WORKER_GAS);
   			assimilator.addWorker(unitID);		
   		} 

		act rightClickUnit(unitID, assimilatorID);
	} 
	
	/**
	 * Remove gas collectors.
	 */
	sequential behavior modifyGasCollectors(AssimilatorWME assimilator, int assimilatorID, int numWorkers, int targetWorkers, int x, int y) {
		precondition {
			(numWorkers > targetWorkers)
			worker = (ProbeWME task==WORKER_GAS ID::unitID x::workerX y::workerY active==true order==MoveToGas)
		}
		specificity 2;
		
   		mental_act {    		
   			assimilator.freeWorker(unitID);		
   			worker.setTask(WORKER_IDLE);
   		} 
	}

	/**
	 * No free gas workers. (Currently in assimilator)
	 */ 
	sequential behavior modifyGasCollectors(AssimilatorWME assimilator, int assimilatorID, int numWorkers, int targetWorkers, int x, int y) {
		specificity 1;
		subgoal WaitFrames(24);
	}
	
    /** 
     * Set minded-out workers back to idle
     */
    sequential behavior checkMinedOut() {    
	    ProbeWME worker;
	    int unitID; 
	    
		with (success_test { 
        	worker = (ProbeWME task==WORKER_MINE order==PlayerGuard ID::unitID)
		}) wait;
		
		mental_act {    		
			if (worker.getNexus() != null) {		
	   			worker.getNexus().freeWorker(unitID);
	   		}
	   		
   			worker.setTask(WORKER_IDLE);
   		} 
    }	

	/**
	 * Force all workers to collect minerals and stop collecting gas.
	 *
	 * Invoke via: spawngoal focusMinerals();
	 */	
   sequential behavior focusMinerals() {     
		with (persistent when_succeeds) subgoal forceMinerals();
    }
    
    /**
     * Iterator for the force minerals behavior.
     */
    sequential behavior forceMinerals() {
    	precondition {
        	assimilator = (AssimilatorWME targetWorkers!=0)
    	}
    	
    	mental_act {
			assimilator.setTargetWorkers(0);    				
    	}
    }	

	/**
	 * Force maximum gas collection.
	 *
	 * Invoke via: spawngoal focusGas();
	 */	
   sequential behavior focusGas() {    
		with (persistent when_succeeds) subgoal forceGas();
    }
    
    /**
     * Iterator for the focus gas behavior.
     */
    sequential behavior forceGas() {
    	precondition {
        	assimilator = (AssimilatorWME targetWorkers!=3)
    	}
    	
    	mental_act {
			assimilator.setTargetWorkers(3);    				
    	}
    }	
     
/******************************************************************************
 * Construction Manager
 *****************************************************************************/

    parallel behavior startConstructionManager() {
	  	with (persistent) subgoal waitForConstructionRequest();	  	
    }

	/**
	 * Wait for construction WMEs to process
	 */ 
    sequential behavior waitForConstructionRequest() {    
		ConstructionWME construction;
    	int timeDeadline;
    
		with (success_test {
			construction = (ConstructionWME)
			(TimerWME frameCount::timeDeadline)
		}) wait;
		
		mental_act {
			timeDeadline = timeDeadline + 90*24;   // 90 second timeout
		}

    	with (persistent when_fails) subgoal processConstructionWME(construction, timeDeadline);
    	
		mental_act {
			BehavingEntity.getBehavingEntity().deleteWME(construction);				
		}		
    } 

	/** 
	 * Failed to build the construction requrest in time.
	 */
    sequential behavior processConstructionWME(ConstructionWME construction, int timeDeadline) {
        precondition {
        	(TimerWME frameCount>=timeDeadline)
        	(Logger.print("ABL", "Construction Timeout!!!!!!!!!")) 
		}    
		specificity 3;
		 
		with (ignore_failure) subgoal freeResources(construction);
	}
    
	/**  
	 * Check if there is any thing to build
	 */
    sequential behavior processConstructionWME(ConstructionWME construction, int timeDeadline) { 
        precondition {
			(construction.getHasRequirements()) 
        	(TimerWME frameCount<timeDeadline) 
        	player =  (PlayerWME)
        	(Logger.print("ABL", "Processing construction request"))  
		}
				
		// check that the player has the necessary tech
		// also check for construction timeout
		context_condition {	
			(ConstructionWME) 	// sensor update
        	(construction.getHasRequirements()==true)    
        	(TimerWME frameCount<timeDeadline)
		} 
		
		int type;
		
		// wait for resources to become available
		with (success_test {
			(player.getMinerals() >= construction.getMineralCost() && player.getGas() >= construction.getGasCost())
		}) wait;
		
		// put a lock on the resources
		mental_act {
			player.addResourceHold(construction.getMineralCost(), construction.getGasCost());		
			construction.setResourcesClaimed();			
			type = construction.getType();
		} 
		
		// go construct it
		subgoal selectConstructor(construction, type);
	}	
 
	/**
	 * Fail the construction if the player lacks necessary tech and free claimed resources.
	 */
    sequential behavior processConstructionWME(ConstructionWME construction) {
        precondition {
        	(construction.getHasRequirements()==false)    
		}    
		
		with (ignore_failure) subgoal freeResources(construction);
				
		// TODO: add a construction failure WME
	}

	/**
	 * Select a worker unit.
	 *
	 * Monitors the health of the constructing unit.
	 */
    sequential behavior selectConstructor(ConstructionWME construction, int type) {
		precondition {
			worker = (ProbeWME task==WORKER_MINE ID::unitID active==true ID::workerID)
		}
		
		context_condition {	
			(ProbeWME ID==unitID)	// force a sensor update
        	(worker.getHitPoints() > 0)    
		}

		// claim the worker unit
		mental_act {
			if (worker.getNexus() != null) {		
			  	worker.getNexus().freeWorker(unitID);
			}
			
   			worker.setNexus(null);
			worker.setTask(WORKER_CONSTRUCT);    
		}
				
		// attempt to construct until success, or a parent context condition fails
		with (persistent when_fails) subgoal selectBuildSite(type, worker, workerID);

		// free worker unit and resources
		with (ignore_failure) subgoal freeResources(construction);

		mental_act {
			worker.setTask(WORKER_IDLE);    
		}		
	}
	
	/** 
	 * Construction has started
	 */
    sequential behavior selectBuildSite(int type, ProbeWME worker, int workerID) {
		precondition {
			event = (NewUnitWME type==type)
		}
		specificity 3;
		
		mental_act {
			BehavingEntity.getBehavingEntity().deleteWME(event);				
		}		
	}	

	/**
	 * Select a build location and construct the strucutre.
	 *
	 * Note: a successful build action causes the context condition to fire. 
	 */
    sequential behavior selectBuildSite(int type, ProbeWME worker, int workerID) {
        precondition {
			!(NewUnitWME type==type)
	    	map = (MapWME)
	    	(map.findBuildingLocation(type, worker.getID(), worker.getX(), worker.getY()))
	    	(MapWME buildingX::x buildingY::y)
//		    timer = (TimerWME time::time)
		}

  		// make sure the building location is clear and timeout not met
		context_condition {	
			(MapWME)	// sensor update
        	(map.isLocationClear(type, x, y, workerID)==true)    
			!(NewUnitWME type==type)
		}
		specificity 2;

		// make sure the location is explored
		with (ignore_failure) act rightClickTile(workerID, x, y);       	
  		subgoal WaitFrames(6);  		  
		with (ignore_failure) act buildTile(workerID, x, y, type);      	
  		subgoal WaitFrames(48);  		  
  		fail_step;
    } 
    
    /**
     * No remaining build spots.
     */
    sequential behavior selectBuildSite(int type, PlayerUnitWME worker, int workerID) {
        precondition {
            (type != Protoss_Pylon)
        	!(ConstructionWME type==Protoss_Pylon)
        	!(PylonWME active==false)
	    	map = (MapWME)
	    	(!map.findBuildingLocation(type, worker.getID(), worker.getX(), worker.getY()))
		}
		specificity 1;
		
		mental_act {
			Logger.print("ABL", "No room, building more pylons");
	        BehavingEntity.getBehavingEntity().addWME(new ConstructionWME(Protoss_Pylon));
		}
		
		// TODO: building failure message
	}    

	/**
	 * Remove resources held if construction has failed/completed.
	 */
    sequential behavior freeResources(ConstructionWME construction) {
        precondition {
        	(construction.getResourcesClaimed()==true)    
        	player =  (PlayerWME)
		}    
		
		mental_act {
			player.removeResourceHold(construction.getMineralCost(), construction.getGasCost());
		}
	}

    
/******************************************************************************
 * Operations Manager
 *****************************************************************************/

    parallel behavior startOperationsManager() {
/*    
	  	with (persistent) subgoal guard();		
*/
	  	with (persistent) subgoal attack();		
	  	with (persistent) subgoal retreat();		
	  	with (persistent) subgoal attackNewTarget();		
	  	with (persistent) subgoal scatterAttack();		 
	  	with (persistent) subgoal flee();		
	  	with (persistent) subgoal fleeDamage();		

	  	with (persistent) subgoal zealotDefendBase();		
	  	with (persistent) subgoal dragoonDefendBase();		
	  	with (persistent) subgoal observerSupport();		
	  	with (persistent) subgoal revealCloakedUnits();		
	  	with (persistent) subgoal revealBurrowedUnits();		
	  	  
	  	with (persistent) subgoal prepareAttack();		 
	  	with (persistent) subgoal beginAttack();		
 
	  	with (persistent) subgoal trainInterceptors();  
    } 
    
    sequential behavior trainInterceptors() {
    	int unitID; 
    	
		with (success_test {
        	(CarrierWME interceptorCount<8 trainTimer==0 ID::unitID)
        	(PlayerWME minerals>=25)
		}) wait; 
        
		act train(unitID, Protoss_Interceptor);		
		subgoal WaitFrames(6);
   	}      

	sequential behavior prepareAttack() {
		int unitID, x, y, forces; 
        GroundUnitWME unit;            
        MapWME map;
        int lastMoved, frameCount;  
	  
		with (success_test {
		    (ReconWME numForces::forces) 
		    (forces < beginAttackSize)
		    (forces >= (beginAttackSize - 3))
			(TimerWME frameCount::frameCount) 
			unit = (GroundUnitWME task==FIGHTER_IDLE ID::unitID order!=Move x::x y::y lastMoved::lastMoved)
			(frameCount > (lastMoved + 250))  
		    map = (MapWME)
		    (Logger.print("ABL", "Rallying unit (prepareAttack): unitID")) 
		}) wait;  
 
		mental_act { 
			unit.setLastMoved(frameCount);		
			Point rally = map.getRallyPoint(x, y);
			if (rally != null) {
				x = rally.x;
				y = rally.y;
				
				x += -2 + (int)(4.0*Math.random());
				y += -2 + (int)(4.0*Math.random());			 
			} 
		}
 
		act attackMoveTile(unitID, x, y);
		subgoal WaitFrames(2); 
    }
    
	sequential behavior beginAttack() {
   
		with (success_test { 
		    (ReconWME numForces>=beginAttackSize) 
		    (Logger.print("ABL", "Beginning Attack: " + beginAttackSize))
		}) wait;
		 
		mental_act {
			endAttackSize = (int)(beginAttackSize * 0.6 + 2);
			
			if (beginAttackSize <= 5) {
				endAttackSize =  beginAttackSize;
			}			
			
	        BehavingEntity.getBehavingEntity().addWME(new RetreatHoldWME());
		} 		

		subgoal WaitFrames(240); 
		
		mental_act {
	        BehavingEntity.getBehavingEntity().deleteAllWMEClass("RetreatHoldWME");
			beginAttackSize += 3;
			beginAttackSize = Math.min(50, beginAttackSize);
		}		
    }
     
   	sequential behavior retreat() {
		int unitID, x, y, zealots, dragoons; 
        GroundUnitWME unit;            
	 
		with (success_test { 
			!(RetreatHoldWME) 
		    (ReconWME numForces<endAttackSize)
			unit = (GroundUnitWME task==FIGHTER_ATTACK ID::unitID takenDamage==true) 
			(NexusWME newest==true x::x y::y nearestEnemy>20)
		    (Logger.print("ABL", "Retreating: " + unitID))
		}) wait; 

		mental_act {
			unit.setTask(FIGHTER_IDLE);			
			unit.setPreviousHealth(); 
			
			x += -10 + (int)(20.0*Math.random());
			y += -10 + (int)(20.0*Math.random());
		}
		 
		act rightClickTile(unitID, x, y);
		spawngoal retreatAttack(unitID, x, y); 
		subgoal WaitFrames(2);
    }

   	sequential behavior retreatAttack(int unitID, int x, int y) {
		subgoal WaitFrames(120);
		act attackMoveTile(unitID, x, y);
	}

    sequential behavior observerSupport() {
        int unitID, allyID;
 
		with (success_test {
			(ObserverWME ID::unitID order==PlayerGuard)  
			!(EnemyUnitWME burrowedOrCloaked==true)
			(GroundUnitWME ID::allyID)
		    (Logger.print("ABL", "Obs follow"))
		}) wait;

		act follow(unitID, allyID);
		subgoal WaitFrames(12);
	}

    sequential behavior revealCloakedUnits() {
        int ex, ey, unitID, frameCount, lastMoved;
		ObserverWME obs;
 
		with (success_test {
			(EnemyUnitWME x::ex y::ey cloaked==true)
			(TimerWME frameCount::frameCount)
			obs = (ObserverWME ID::unitID lastMoved::lastMoved)  
			(frameCount > (lastMoved + 300))
		    (Logger.print("ABL", "Obs revealing cloaked"))
		}) wait;
 
		mental_act { 
			obs.setLastMoved(frameCount);			
		}
		
		act rightClickTile(unitID, ex, ey);
		subgoal WaitFrames(48);
	} 
   
    sequential behavior revealBurrowedUnits() {
        int ex, ey, unitID, frameCount, lastMoved;
		ObserverWME obs;
  
		with (success_test {
			(EnemyUnitWME x::ex y::ey burrowed==true)
			(TimerWME frameCount::frameCount)
			obs = (ObserverWME ID::unitID lastMoved::lastMoved)  
			(frameCount > (lastMoved + 500)) 			
		    (Logger.print("ABL", "Obs revealing burrowed"))
		}) wait;
 
		mental_act {
			obs.setLastMoved(frameCount);			
		}
		
		act rightClickTile(unitID, ex, ey);
		subgoal WaitFrames(48);
	}
 
    sequential behavior zealotDefendBase() {
        int ex, ey, nx, ny, unitID, typeID;
    
		with (success_test {
			(ZealotWME ID::unitID order==PlayerGuard)
			(EnemyUnitWME x::ex y::ey burrowed==false isFlyer==false)
			(NexusWME x::nx y::ny)
			(Math.abs(ex - nx) < 20 && Math.abs(ey - ny) < 20)
		}) wait;

		act attackMoveTile(unitID, ex, ey);
		subgoal WaitFrames(2);  
	}     
          
    sequential behavior dragoonDefendBase() { 
        int ex, ey, nx, ny, unitID, typeID;
  
		with (success_test {
			(DragoonWME ID::unitID order==PlayerGuard)
			(EnemyUnitWME x::ex y::ey burrowed==false typeID!=Protoss_Observer)
			(NexusWME x::nx y::ny)
			(Math.abs(ex - nx) < 20 && Math.abs(ey - ny) < 20)
		}) wait; 

		act attackMoveTile(unitID, ex, ey);
		subgoal WaitFrames(2); 
	}    

    /**
     * Tell me units to move to the rally point.
     */
/*   
    sequential behavior guard() {
        int unitID, x, y;
        GroundUnitWME unit;            
		MapWME map; 
		Point point;                   
                    
		with (success_test {
			unit = (GroundUnitWME task==FIGHTER_IDLE active==true ID::unitID)
			map = (MapWME)
		}) wait;
		
		mental_act {
			point = map.getRallyPoint(x, y);
			x = point.x;
			y = point.y;
		}
  
		act rightClickTile(unitID, x, y);
		subgoal WaitFrames(1);
		
		// change state a few frames after the initial order is given, so later attack actions are not ignored
		mental_act {
			unit.setTask(FIGHTER_GUARD);			
		}
	} 
*/
	 
	/** 
	 * Begins an attack.
     * 	 
	 * TODO: squad target 
	 */
	sequential behavior attack() {
		int unitID, x, y; 
        GroundUnitWME unit;            
	 
		with (success_test {
		    (ReconWME numForces>=beginAttackSize) 
			unit = (GroundUnitWME task==FIGHTER_IDLE ID::unitID order!=Move)
			(ParticleWME x::x y::y) 
		}) wait;
 
		mental_act {
			unit.setTask(FIGHTER_ATTACK);			
			unit.setPreviousHealth();
		}   
		
//		act attackMoveTile(unitID, x, y);

		// grouping behavior
		spawngoal regroup(unit, unitID, x, y);		 
    }

	sequential behavior regroup(GroundUnitWME unit, int unitID, int attackX, int attackY) {
		precondition { 
			!(EnemyUnitWME)
			(unit.getTask()==FIGHTER_ATTACK)
		}
 
		int leaderX, leaderY;
		MapWME map;

		act attackMoveTile(unitID, attackX, attackY);
	 	subgoal WaitFrames(240);
	 			 
		with (success_test { 
			map = (MapWME)
		    (map.setTarget(attackX, attackY))
			(MapWME leaderX::leaderX leaderY::leaderY)
		}) subgoal fail(); 
       
		subgoal regroupMove(unit, unitID, leaderX, leaderY);   
		subgoal WaitFrames(60);						
		spawngoal regroup(unit, unitID, attackX, attackY);		 
    }  

    sequential behavior fail() {
    	fail_step; 
    }
  
	sequential behavior regroupMove(GroundUnitWME unit, int unitID, int attackX, int attackY) { 
		precondition {
			(unit.getTask()==FIGHTER_ATTACK)
		}
		
		act attackMoveTile(unitID, attackX, attackY);
	}

	/**
	 * Continues an attack: unit is idle.
     * 	 
	 * TODO: squad target 
	 */
	sequential behavior attackNewTarget() {
		int unitID, x, y;
        GroundUnitWME unit;             
	 
		with (success_test {
			unit = (GroundUnitWME task==FIGHTER_ATTACK order==PlayerGuard ID::unitID)
			(ParticleWME x::x y::y)
		}) wait;

		mental_act {
			unit.setTask(FIGHTER_ATTACK);			
			unit.setPreviousHealth();
		}
		
		act attackMoveTile(unitID, x, y);
    }    
 
	/**
	 * In attack mode, but no enemy units or particles.
     * 	 
	 * TODO: squad target 
	 */
	sequential behavior scatterAttack() {
		int unitID, x, y;
        GroundUnitWME unit;             
	 
		with (success_test { 
			unit = (GroundUnitWME task==FIGHTER_ATTACK order==PlayerGuard ID::unitID x::x y::y)
			!(ParticleWME)
		}) wait;

		mental_act {
			unit.setTask(FIGHTER_ATTACK);			
			unit.setPreviousHealth();
			System.err.println("Ground units Scattering");
			
			// scatter
			x += -10 + (int)(20.0*Math.random());
			y += -10 + (int)(20.0*Math.random());
		}
		
		act attackMoveTile(unitID, x, y);
    }    
    
    /**
     * Fall back if damage taken.
     */
	sequential behavior flee() {
		int unitID, nexusID, task;
        FleeUnitWME unit;             
	  
		with (success_test { 
			(ReconWME enemyTanks==false enemyBunkers==false enemyCannons==false enemySunkens==false)
			unit = (FleeUnitWME task::task takenDamage==true ID::unitID groundCooldown>0 groundCooldown<26 order==AttackUnit)
			(task==FIGHTER_ATTACK || task==FIGHTER_GUARD || task==FIGHTER_IDLE)
 			(NexusWME ID::nexusID)	// TODO: closest Nexus?
		}) wait; 
		
		mental_act { 
			unit.setTask(FIGHTER_FLEE);			 
		}
  
		act rightClickUnit(unitID, nexusID);
		spawngoal flee(unit, unitID);	
		subgoal WaitFrames(1);
	} 

	sequential behavior fleeDamage() {
		int unitID, nexusID, task;
        DragoonWME dragoon;             
 	  
		with (success_test { 
			dragoon = (DragoonWME task::task takenDamage==true hitPoints<90 ID::unitID groundCooldown>0 groundCooldown<26 order==AttackUnit)
			(task==FIGHTER_ATTACK || task==FIGHTER_GUARD || task==FIGHTER_IDLE)
 			(NexusWME ID::nexusID)
		}) wait; 
		
		mental_act {
			dragoon.setTask(FIGHTER_FLEE);			 
		}

		act rightClickUnit(unitID, nexusID);
		spawngoal flee(dragoon, unitID);	
		subgoal WaitFrames(1);
	} 
	 
	/**
     * Hold to fire then re-engage.
     */	
	sequential behavior flee(FleeUnitWME unit, int unitID) {
		subgoal WaitFrames(24);
		
		mental_act {
			unit.setPreviousHealth();
			unit.setTask(FIGHTER_ATTACK);			
		}

		// find a target
		subgoal reattack(unitID);
	} 

	/**
	 * Re-initiate the attack.
	 *
	 * TODO: squad target  
	 */	
	sequential behavior reattack(int unitID) {
		precondition {
			(ParticleWME x::x y::y)
		}
		
		act attackMoveTile(unitID, x, y);
	}
 
    
/******************************************************************************
 * Utilities
 *****************************************************************************/

    /**
     * waits for a specified number of frames
     */
	sequential behavior WaitFrames(int frames) {
		int finishFrame;
	    mental_act {
	    	finishFrame = ABLStarCraftBot.getGame().getGameFrame() + frames;
	    }

	    with ( success_test { (ABLStarCraftBot.getGame().getGameFrame() >= finishFrame) } ) wait;
	}

	sequential behavior continueBehavior(boolean success) {
		precondition { (success==true) }
		succeed_step;
	}	

	sequential behavior continueBehavior(boolean success) {
		precondition { (success==false) }
		succeed_step;
	}	
	
	// keypress trigged behaviors
	sequential behavior keyPressListener() {
		with (persistent) subgoal processKeypresses();
	}	
	 
	sequential behavior processKeypresses() {
		KeyPressWME event;
		int keycode;
	
	    with ( success_test { 
	    	event = (KeyPressWME keycode::keycode) 
	    }) wait;

		with (ignore_failure) subgoal keyPress(keycode);

		mental_act {
   			Logger.print("ABL", "keycode: " + keycode);
			BehavingEntity.getBehavingEntity().deleteWME(event);				
		}			
	}
	
	sequential behavior keyPress(int keycode) {
		precondition {(keycode==VK_M)}		
		spawngoal focusMinerals();
	}

	sequential behavior keyPress(int keycode) {
		precondition {(keycode==VK_G)}		
		spawngoal focusGas();
	}

/*  
	sequential behavior keyPress(int keycode) {
		precondition {(keycode==VK_R)}		
		spawngoal retreat();
	}
*/

/******************************************************************************
 * Initial Tree
 *****************************************************************************/

    /**
     * Inital behavior tree.
     */
    initial_tree {
    	subgoal startup();
    }
}
